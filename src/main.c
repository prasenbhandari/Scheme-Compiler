#include <stdio.h>
#include <stdlib.h>
#include "scanner/scanner.h"
#include "scanner/token.h"
#include "utils/buffer.h"
#include "utils/error.h"
#include "parser/parser.h"
#include "analyzer/analyzer.h"
#include "vm/vm.h"
#include "vm/instruction.h" 
#include "vm/value.h"
#include "vm/debug.h"
#include "codegen/codegen.h"

int main(int argc, char *argv[]) {
    // Run VM test first
    
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    init_error(argv[1]);
    FILE *file = fopen(argv[1], "r");
    if (!file) {
        report_error(0, 0, "Could not open file '%s'", argv[1]);
        return 1;
    }

    Parser* p = init_parser(file);
    if (!p) {
        fprintf(stderr, "Failed to initialize parser\n");
        fclose(file);
        return 1;
    }

    Analyzer* a = init_analyzer();
    if (!a){
        fprintf(stderr, "Failed to initialize analyzer\n");
        fclose(file);
        return 1;
    }

    // Check for errors during scanning initialization
    if (had_error()) {
        fprintf(stderr, "\nCompilation failed with errors.\n");
        cleanup_scanner();
        fclose(file);
        return 1;
    }

    // Parse and print AST
    printf("Parsing file: %s\n", argv[1]);
    printf("=================\n\n");
    
    // PHASE 1: Parse all expressions into array
    int expr_capacity = 100;
    AstNode** expressions = malloc(sizeof(AstNode*) * expr_capacity);  // Initial capacity
    int expr_count = 0;
    
    while (p->current != NULL) {
        AstNode* ast = parse_expression(p);
        
        if (!ast) {
            if (!p->current) {
                break;
            }
            continue;
        }

        // Grow array if needed
        if (expr_count >= expr_capacity) {
            expr_capacity *= 2;
            expressions = realloc(expressions, sizeof(AstNode*) * expr_capacity);
        }
        
        expressions[expr_count++] = ast;
    }
    
    printf("Parsed %d expressions\n\n", expr_count);

    // PHASE 2: Analyze all expressions
    printf("=== Semantic Analysis ===\n");
    for (int i = 0; i < expr_count; i++) {
        if (!analyze_ast(a, expressions[i])) {
            fprintf(stderr, "Failed to analyze expression %d\n", i);
            // Clean up and exit
            for (int j = 0; j < expr_count; j++) {
                free_ast(expressions[j]);
            }
            free(expressions);
            cleanup_scanner();
            free_parser(p);
            free_analyzer(a);
            fclose(file);
            return 1;
        }
    }
    printf("Analysis complete\n\n");

    // PHASE 3: Compile all expressions into single bytecode chunk
    printf("=== Code Generation ===\n");
    Bytecode* program = malloc(sizeof(Bytecode));
    init_bytecode(program);
    
    for (int i = 0; i < expr_count; i++) {
        codegen_expr(program, expressions[i]);  // Append to same bytecode
    }
    emit_instruction(program, OP_HALT, 0);  // Add halt at end
    
    printf("Generated bytecode for %d expressions\n\n", expr_count);

    // Optional: disassemble to see generated bytecode
    disassemble_bytecode(program, "Complete Program");

    // PHASE 4: Execute the complete program
    printf("\n=== Executing ===\n");
    VM vm;
    init_vm(&vm);
    vm.trace_execution = true;  // Enable tracing
    vm_execute(&vm, program);

    // Cleanup
    free_vm(&vm);
    free_bytecode(program);
    free(program);
    
    for (int i = 0; i < expr_count; i++) {
        free_ast(expressions[i]);
    }
    free(expressions);

    cleanup_scanner();
    free_parser(p);
    free_analyzer(a);
    fclose(file);

    return had_error() ? 1 : 0;
}
